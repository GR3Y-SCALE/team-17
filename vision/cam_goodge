import cv2
import numpy as np
import math
from sklearn.cluster import DBSCAN

# Camera setup
frame_cap = cv2.VideoCapture(0)

# Camera Configuration Constants (mm)
FOCAL_LENGTH = 2.9
SENSOR_HEIGHT = 2.4
SENSOR_WIDTH = 3.2
CAM_FOV = 140  # degrees

# Detection Thresholds
MIN_CONTOUR_AREA = 200
CIRCULARITY_THRESHOLD = 0.85
SQUARE_ASPECT_RATIO_MIN = 0.9
SQUARE_ASPECT_RATIO_MAX = 1.1

# Known Object Sizes (mm)
SINGLE_CIRCLE_SIZE = 70
MULTI_CIRCLE_SIZE = 120
SQUARE_SIZE = 50
PLATFORM_SPACING = 300

# HSV Color Ranges
lower_black_pick = np.array([0, 0, 0])
upper_black_pick = np.array([180, 255, 130])
lower_black_aisle = np.array([0, 0, 0])
upper_black_aisle = np.array([180, 100, 130])

lower_orange1 = np.array([0, 120, 80])
upper_orange1 = np.array([15, 255, 255])
lower_orange2 = np.array([170, 120, 80])
upper_orange2 = np.array([180, 255, 255])

lower_yellow = np.array([20, 152, 149])
upper_yellow = np.array([40, 255, 255])

lower_blue = np.array([60, 50, 60])
upper_blue = np.array([150, 255, 255])

lower_white = np.array([0, 0, 150])
upper_white = np.array([80, 55, 255])

lower_green = np.array([65, 200, 95]) # From old code
upper_green = np.array([85, 255, 190])


def compute_distance_and_bearing(bbox, frame_shape, known_size_mm):
    """ Calculate distance and bearing to object based on bounding box"""
    x, y, w, h = bbox
    target_x = int(x + w / 2)
    target_y = int(y + h / 2)

    # Calculate distance using pinhole camera model
    object_size = max(w, h)
    img_height_px = frame_shape[0]
    distance_mm = (FOCAL_LENGTH * known_size_mm * img_height_px) / (object_size * SENSOR_HEIGHT)
    distance_m = distance_mm / 1000

    # Calculate bearing angle from center of frame
    img_width_px = frame_shape[1]
    mid_px = target_x - (img_width_px / 2)
    bearing_deg = (CAM_FOV * mid_px) / img_width_px

    return target_x, target_y, distance_m, bearing_deg


def detect_circles(contours_black, frame): # Changed from contours to contours_black
    """ Detect circular objects from contours """
    circles = []

    for contour in contours_black:
        area = cv2.contourArea(contour)
        perimeter = cv2.arcLength(contour, True)

        if perimeter > 0 and area > MIN_CONTOUR_AREA:
            circularity = (4 * math.pi * area) / (perimeter * perimeter)
            if circularity > CIRCULARITY_THRESHOLD:
                (x, y), radius = cv2.minEnclosingCircle(contour)
                center = (int(x), int(y))
                radius = int(radius)
                circles.append((center, radius))

                # Draw circle and label
                cv2.circle(frame, center, radius, (0, 255, 0), 2)
                cv2.putText(frame, "Circle", (center[0] - 30, center[1] - 10), 
                          cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 255, 0), 2)

    return circles


def detect_squares(contours_black, frame): # Changed from contours to contours_black
    """ Detect square objects from contours """
    square_centers = []

    for contour in contours_black:
        area = cv2.contourArea(contour)
        perimeter = cv2.arcLength(contour, True)

        if perimeter > 0 and area > MIN_CONTOUR_AREA:
            approx = cv2.approxPolyDP(contour, 0.02 * perimeter, True)
            if len(approx) == 4:
                x, y, w, h = cv2.boundingRect(approx)
                aspect_ratio = float(w) / h

                if SQUARE_ASPECT_RATIO_MIN <= aspect_ratio <= SQUARE_ASPECT_RATIO_MAX:
                    cx_square = x + w // 2
                    cy_square = y + h // 2
                    square_centers.append([cx_square, cy_square])

                # Draw rectangle around detected square
                cv2.rectangle(frame, (x, y), (x + w, y + h), (0, 0, 255), 2)

    return square_centers


def process_circle_groups(circles, frame):
    """ Process groups of circles and calculate distance/bearing using DBSCAN clustering """
    if not circles:
        return None

    # Extract circle centers for clustering
    circle_centers = []
    for (center, radius) in circles:
        circle_centers.append([center[0], center[1]])
    
    circle_centers_array = np.array(circle_centers)
    
    # Use DBSCAN to cluster circles based on proximity
    # eps=80 for circles (smaller than squares since circles are typically closer together)
    clustering = DBSCAN(eps=80, min_samples=1).fit(circle_centers_array)
    labels = clustering.labels_
    
    for group_id in np.unique(labels):
        members_array = circle_centers_array[labels == group_id]
        group_center_x = np.mean(members_array[:, 0])
        group_center_y = np.mean(members_array[:, 1])
        
        num_circles = len(members_array)
        
        # Determine object size and known size based on number of circles in group
        if num_circles == 1:
            # Single circle - use radius * 2 as object size
            circle_idx = np.where(labels == group_id)[0][0]
            _, radius = circles[circle_idx]
            object_size = radius * 2
            known_size_mm = SINGLE_CIRCLE_SIZE
            group_label = "Row Marker 1"
            
        elif num_circles == 2:
            # Two circles - use distance between centers
            circle_indices = np.where(labels == group_id)[0]
            center1 = circle_centers[circle_indices[0]]
            center2 = circle_centers[circle_indices[1]]
            object_size = math.dist(center1, center2)
            known_size_mm = MULTI_CIRCLE_SIZE
            group_label = "Row Marker 2"
            
        else:  # 3 or more circles
            # Multiple circles - use average distance between all pairs
            circle_indices = np.where(labels == group_id)[0]
            distances = []
            for i in range(len(circle_indices)):
                for j in range(i + 1, len(circle_indices)):
                    center_i = circle_centers[circle_indices[i]]
                    center_j = circle_centers[circle_indices[j]]
                    distances.append(math.dist(center_i, center_j))
            object_size = np.mean(distances) if distances else 50  # fallback
            known_size_mm = MULTI_CIRCLE_SIZE
            group_label = "Row Marker 3"

        # Calculate distance and bearing for the group
        target_x, target_y = int(group_center_x), int(group_center_y)
        
        img_height_px = frame.shape[0]
        distance_mm = (FOCAL_LENGTH * known_size_mm * img_height_px) / (object_size * SENSOR_HEIGHT)
        distance_m = distance_mm / 1000

        img_width_px = frame.shape[1]
        pixels_from_center = target_x - (img_width_px / 2)
        bearing_deg = (CAM_FOV * pixels_from_center) / img_width_px

        # Draw group visualization
        cv2.putText(frame, group_label, (target_x - 50, target_y - 110),
                   cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 255, 0), 2)
        cv2.circle(frame, (target_x, target_y), 10, (0, 255, 0), 2)

        # Add distance/bearing text
        cv2.putText(frame, f"{group_label}: {distance_m:.2f} m, {bearing_deg:.1f} deg",
                   (target_x - 80, target_y + 40),
                   cv2.FONT_HERSHEY_DUPLEX, 0.5, (255, 255, 255), 1, cv2.LINE_AA)

        return distance_m, bearing_deg

    return None


# def simple_cluster_squares(square_centers, max_distance=100):
#     """ Simple distance-based clustering for square centers """
#     if not square_centers:
#         return []
    
#     groups = []
#     used = [False] * len(square_centers)
    
#     for i, center in enumerate(square_centers):
#         if used[i]:
#             continue
            
#         # Start new group
#         group = [center]
#         used[i] = True
        
#         # Find nearby squares
#         for j, other_center in enumerate(square_centers):
#             if used[j]:
#                 continue
            
#             # Calculate distance between centers
#             distance = math.sqrt((center[0] - other_center[0])**2 + (center[1] - other_center[1])**2)
            
#             if distance <= max_distance:
#                 group.append(other_center)
#                 used[j] = True
        
#         groups.append(group)
    
#     return groups


def process_square_groups(square_centers, frame):
    """ Process groups of squares and calculate distance/bearing """
    if not square_centers:
        return None
    
    # Cluster squares based on proximity
    # groups = simple_cluster_squares(square_centers, max_distance=100)

    square_centers_array = np.array(square_centers)
    clustering = DBSCAN(eps=100, min_samples=1).fit(square_centers_array)
    labels = clustering.labels_
    
    for group_id in np.unique(labels):
        members_array = square_centers_array[labels == group_id]
        group_center_x = np.mean(members_array[:, 0])
        group_center_y = np.mean(members_array[:, 1])

        # Determine platform type based on number of squares
        num_squares = len(members_array)
        if num_squares == 1:
            group_label = "Platform 1"
        elif num_squares == 2:
            group_label = "Platform 2"
        elif num_squares == 3:
            group_label = "Platform 3"
        else:
            group_label = f"Group: {num_squares} squares"

        # Draw group visualization
        cv2.putText(frame, group_label, (int(group_center_x) - 50, int(group_center_y) - 110),
                   cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 0, 0), 2)
        cv2.circle(frame, (int(group_center_x), int(group_center_y)), 10, (255, 0, 0), 2)

        # Calculate distance and bearing for the group
        bbox_w, bbox_h = SQUARE_SIZE, SQUARE_SIZE
        _, _, distance_m, bearing_deg = compute_distance_and_bearing(
            (group_center_x - bbox_w/2, group_center_y - bbox_h/2, bbox_w, bbox_h),
            frame.shape,
            PLATFORM_SPACING
        )

        # Add distance/bearing text
        cv2.putText(frame, f"{group_label}: {distance_m:.2f} m, {bearing_deg:.1f} deg",
                   (int(group_center_x) - 80, int(group_center_y) + 40),
                   cv2.FONT_HERSHEY_DUPLEX, 0.5, (255, 255, 255), 1, cv2.LINE_AA)

        return distance_m, bearing_deg

    return None

def camera_operation():
    """ Main camera operation function - maintains original interface for backwards compatibility """
    # Initialize return variables
    items_rb = []
    packing_station_rb = []
    obstacles_rb = []
    row_marker_rb = []
    shelf_rb = []
    picking_station_rb = []
    debug_mode = False

    print("Camera operation started. Press 'q' to quit, 'd' to toggle debug mode.")

    while True:
        # Capture and preprocess frame
        frame = frame_cap.read()[1]

        frame = cv2.resize(frame, (640, 480))
        frame = cv2.rotate(frame, cv2.ROTATE_180) # IF NEEDED
        hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)

        # Create color masks
        mask_black_pick = cv2.inRange(hsv, lower_black_pick, upper_black_pick)
        mask_black_aisle = cv2.inRange(hsv, lower_black_aisle, upper_black_aisle)
        # mask_black = cv2.inRange(hsv, lower_black_aisle, upper_black_aisle)       
        mask_orange = cv2.inRange(hsv, lower_orange1, upper_orange1) | cv2.inRange(hsv, lower_orange2, upper_orange2)
        mask_yellow = cv2.inRange(hsv, lower_yellow, upper_yellow)
        mask_blue = cv2.inRange(hsv, lower_blue, upper_blue)
        mask_white = cv2.inRange(hsv, lower_white, upper_white)
        mask_green = cv2.inRange(hsv, lower_green, upper_green)

        colour_masks = {
            "Object":   (mask_orange,   (0, 140, 255),  70),
            "Platform": (mask_yellow,   (0, 255, 255),  120),
            "Shelf":    (mask_blue,     (255, 0, 0),    150),
            "Walls":    (mask_white,    (255, 255, 255), 500),
            "Obstacles":(mask_green,    (0, 255, 0),    200)
        }


        for label, (mask, draw_colour, known_size_mm) in colour_masks.items():
            contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
            for contour in contours:
                if cv2.contourArea(contour) > 500:
                    cv2.drawContours(frame, [contour], -1, draw_colour, 2)
                    x, y, w, h = cv2.boundingRect(contour)

                    M = cv2.moments(contour)
                    if M["m00"] > 0:
                        cx = int(M["m10"]/M["m00"])
                        cy = int(M["m01"]/M["m00"])
                        cv2.putText(frame, label, (cx-30, cy-10), cv2.FONT_HERSHEY_SIMPLEX, 0.6, draw_colour, 2)
        
                    # ===== DISTANCE AND BEARING =====
                    _, _, distance_m, bearing_deg = compute_distance_and_bearing((x, y, w, h), frame.shape, known_size_mm)
                    text = f"{label}: {distance_m:.2f} m, {bearing_deg:.1f} degrees"
                    cv2.putText(frame, text, (x+w+5, y+h-5), cv2.FONT_HERSHEY_DUPLEX, 0.5, (0,0,0), 1, cv2.LINE_AA)

        # ===== RETURN VARIABLES FOR COLOR DETECTION =====
        if label == "Platform":
            packing_station_rb.append((distance_m, bearing_deg))
        elif label == "Shelf":
            shelf_rb.append((distance_m, bearing_deg))

        # Find contours in black mask
        contours_black_aisle, _ = cv2.findContours(mask_black_aisle, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        contours_black_pick, _ = cv2.findContours(mask_black_pick, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

        # Detect circles first
        circles = detect_circles(contours_black_aisle, frame)
        circle_count = len(circles)

        # Only detect squares if no circles found
        square_centers = []
        square_count = 0
        if circle_count == 0:
            square_centers = detect_squares(contours_black_pick, frame)
            square_count = len(square_centers)

        # Process circle groups for row markers
        if circles:
            circle_result = process_circle_groups(circles, frame)
            if circle_result:
                distance_m, bearing_deg = circle_result
                if len(circles) == 1:
                    row_marker_rb = [(distance_m, bearing_deg), None, None]
                elif len(circles) == 2:
                    row_marker_rb = [None, (distance_m, bearing_deg), None]
                elif len(circles) >= 3:
                    row_marker_rb = [None, None, (distance_m, bearing_deg)]

        # Process square groups for picking stations
        if square_centers:
            square_result = process_square_groups(square_centers, frame)
            if square_result:
                distance_m, bearing_deg = square_result
                if len(square_centers) == 1:
                    picking_station_rb = [(distance_m, bearing_deg), None, None]
                elif len(square_centers) == 2:
                    picking_station_rb = [None, (distance_m, bearing_deg), None]
                elif len(square_centers) >= 3:
                    picking_station_rb = [None, None, (distance_m, bearing_deg)]

        # Add shape count overlay
        if circle_count > 0 or square_count > 0:
            text = f"Circles: {circle_count}" if circle_count > 0 else f"Squares: {square_count}"
            # Add black outline for better visibility
            cv2.putText(frame, text, (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 0, 0), 8, cv2.LINE_AA)
            cv2.putText(frame, text, (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 0, 255), 2, cv2.LINE_AA)

        # Display results
        cv2.imshow("Frame", frame)
        if debug_mode:
            combined_mask = mask_orange | mask_yellow | mask_blue | mask_black_pick | mask_black_aisle | mask_white | mask_green
            cv2.imshow("Debug Masks", combined_mask)

        # Handle keyboard input
        key = cv2.waitKey(1) & 0xFF
        if key == ord('q'):
            break
        elif key == ord('d'):
            debug_mode = not debug_mode
            print(f"Debug mode: {'ON' if debug_mode else 'OFF'}")
            if not debug_mode:
                cv2.destroyWindow("Debug Masks")

    cv2.destroyAllWindows()
    return (items_rb, packing_station_rb, obstacles_rb, row_marker_rb, shelf_rb, picking_station_rb)

if __name__ == "__main__":
    camera_operation()